{"ast":null,"code":"import { invariant } from \"../utilities/globals/index.js\";\nimport { createFragmentMap, getFragmentDefinitions, getOperationDefinition } from \"../utilities/index.js\";\nimport { maskDefinition } from \"./maskDefinition.js\";\nimport { MapImpl, SetImpl, warnOnImproperCacheImplementation } from \"./utils.js\";\n/** @internal */\nexport function maskOperation(data, document, cache) {\n  var _a;\n  if (!cache.fragmentMatches) {\n    if (globalThis.__DEV__ !== false) {\n      warnOnImproperCacheImplementation();\n    }\n    return data;\n  }\n  var definition = getOperationDefinition(document);\n  invariant(definition, 51);\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n  return maskDefinition(data, definition.selectionSet, {\n    operationType: definition.operation,\n    operationName: (_a = definition.name) === null || _a === void 0 ? void 0 : _a.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache: cache,\n    mutableTargets: new MapImpl(),\n    knownChanged: new SetImpl()\n  });\n}","map":{"version":3,"sources":["../../src/masking/maskOperation.ts"],"names":[],"mappings":"AAKA,SAAS,SAAS,QAAQ,+BAA+B;AACzD,SACE,iBAAiB,EACjB,sBAAsB,EACtB,sBAAsB,QACjB,uBAAuB;AAC9B,SAAS,cAAc,QAAQ,qBAAqB;AACpD,SACE,OAAO,EACP,OAAO,EACP,iCAAiC,QAC5B,YAAY;AAEnB;AACA,OAAM,SAAU,aAAa,CAC3B,IAAW,EACX,QAAiD,EACjD,KAA2B,EAAA;;EAE3B,IAAI,CAAC,KAAK,CAAC,eAAe,EAAE;IAC1B,IAAI,UAAU,CAAA,OAAA,KAAA,KAAA,EAAA;MACZ,iCAAiC,CAAA,CAAE;IACrC;IAEA,OAAO,IAAI;EACb;EAEA,IAAM,UAAU,GAAG,sBAAsB,CAAC,QAAQ,CAAC;EAEnD,SAAS,CACP,UAAU,EACV,EAAA,CAAA;EAGF,IAAI,IAAI,IAAI,IAAI,EAAE;IAChB;IACA,OAAO,IAAI;EACb;EAEA,OAAO,cAAc,CAAC,IAAI,EAAE,UAAU,CAAC,YAAY,EAAE;IACnD,aAAa,EAAE,UAAU,CAAC,SAAS;IACnC,aAAa,EAAE,CAAA,EAAA,GAAA,UAAU,CAAC,IAAI,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,KAAK;IACrC,WAAW,EAAE,iBAAiB,CAAC,sBAAsB,CAAC,QAAQ,CAAC,CAAC;IAChE,KAAK,EAAA,KAAA;IACL,cAAc,EAAE,IAAI,OAAO,CAAA,CAAE;IAC7B,YAAY,EAAE,IAAI,OAAO,CAAA;GAC1B,CAAC;AACJ","sourcesContent":["import type {\n  ApolloCache,\n  DocumentNode,\n  TypedDocumentNode,\n} from \"../core/index.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport {\n  createFragmentMap,\n  getFragmentDefinitions,\n  getOperationDefinition,\n} from \"../utilities/index.js\";\nimport { maskDefinition } from \"./maskDefinition.js\";\nimport {\n  MapImpl,\n  SetImpl,\n  warnOnImproperCacheImplementation,\n} from \"./utils.js\";\n\n/** @internal */\nexport function maskOperation<TData = unknown>(\n  data: TData,\n  document: DocumentNode | TypedDocumentNode<TData>,\n  cache: ApolloCache<unknown>\n): TData {\n  if (!cache.fragmentMatches) {\n    if (__DEV__) {\n      warnOnImproperCacheImplementation();\n    }\n\n    return data;\n  }\n\n  const definition = getOperationDefinition(document);\n\n  invariant(\n    definition,\n    \"Expected a parsed GraphQL document with a query, mutation, or subscription.\"\n  );\n\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n\n  return maskDefinition(data, definition.selectionSet, {\n    operationType: definition.operation,\n    operationName: definition.name?.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache,\n    mutableTargets: new MapImpl(),\n    knownChanged: new SetImpl(),\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}