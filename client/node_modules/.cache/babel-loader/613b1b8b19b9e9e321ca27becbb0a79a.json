{"ast":null,"code":"import { Kind } from \"graphql\";\nimport { getFragmentMaskMode, maybeDeepFreeze, resultKeyNameFromField } from \"../utilities/index.js\";\nimport { disableWarningsSlot } from \"./utils.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\nexport function maskDefinition(data, selectionSet, context) {\n  return disableWarningsSlot.withValue(true, function () {\n    var masked = maskSelectionSet(data, selectionSet, context, false);\n    if (Object.isFrozen(data)) {\n      maybeDeepFreeze(masked);\n    }\n    return masked;\n  });\n}\nfunction getMutableTarget(data, mutableTargets) {\n  if (mutableTargets.has(data)) {\n    return mutableTargets.get(data);\n  }\n  var mutableTarget = Array.isArray(data) ? [] : Object.create(null);\n  mutableTargets.set(data, mutableTarget);\n  return mutableTarget;\n}\nfunction maskSelectionSet(data, selectionSet, context, migration, path) {\n  var _a;\n  var knownChanged = context.knownChanged;\n  var memo = getMutableTarget(data, context.mutableTargets);\n  if (Array.isArray(data)) {\n    for (var _i = 0, _b = Array.from(data.entries()); _i < _b.length; _i++) {\n      var _c = _b[_i],\n        index = _c[0],\n        item = _c[1];\n      if (item === null) {\n        memo[index] = null;\n        continue;\n      }\n      var masked = maskSelectionSet(item, selectionSet, context, migration, globalThis.__DEV__ !== false ? \"\".concat(path || \"\", \"[\").concat(index, \"]\") : void 0);\n      if (knownChanged.has(masked)) {\n        knownChanged.add(memo);\n      }\n      memo[index] = masked;\n    }\n    return knownChanged.has(memo) ? memo : data;\n  }\n  for (var _d = 0, _e = selectionSet.selections; _d < _e.length; _d++) {\n    var selection = _e[_d];\n    var value = void 0;\n    // we later want to add acessor warnings to the final result\n    // so we need a new object to add the accessor warning to\n    if (migration) {\n      knownChanged.add(memo);\n    }\n    if (selection.kind === Kind.FIELD) {\n      var keyName = resultKeyNameFromField(selection);\n      var childSelectionSet = selection.selectionSet;\n      value = memo[keyName] || data[keyName];\n      if (value === void 0) {\n        continue;\n      }\n      if (childSelectionSet && value !== null) {\n        var masked = maskSelectionSet(data[keyName], childSelectionSet, context, migration, globalThis.__DEV__ !== false ? \"\".concat(path || \"\", \".\").concat(keyName) : void 0);\n        if (knownChanged.has(masked)) {\n          value = masked;\n        }\n      }\n      if (!(globalThis.__DEV__ !== false)) {\n        memo[keyName] = value;\n      }\n      if (globalThis.__DEV__ !== false) {\n        if (migration && keyName !== \"__typename\" &&\n        // either the field is not present in the memo object\n        // or it has a `get` descriptor, not a `value` descriptor\n        // => it is a warning accessor and we can overwrite it\n        // with another accessor\n        !((_a = Object.getOwnPropertyDescriptor(memo, keyName)) === null || _a === void 0 ? void 0 : _a.value)) {\n          Object.defineProperty(memo, keyName, getAccessorWarningDescriptor(keyName, value, path || \"\", context.operationName, context.operationType));\n        } else {\n          delete memo[keyName];\n          memo[keyName] = value;\n        }\n      }\n    }\n    if (selection.kind === Kind.INLINE_FRAGMENT && (!selection.typeCondition || context.cache.fragmentMatches(selection, data.__typename))) {\n      value = maskSelectionSet(data, selection.selectionSet, context, migration, path);\n    }\n    if (selection.kind === Kind.FRAGMENT_SPREAD) {\n      var fragmentName = selection.name.value;\n      var fragment = context.fragmentMap[fragmentName] || (context.fragmentMap[fragmentName] = context.cache.lookupFragment(fragmentName));\n      invariant(fragment, 47, fragmentName);\n      var mode = getFragmentMaskMode(selection);\n      if (mode !== \"mask\") {\n        value = maskSelectionSet(data, fragment.selectionSet, context, mode === \"migrate\", path);\n      }\n    }\n    if (knownChanged.has(value)) {\n      knownChanged.add(memo);\n    }\n  }\n  if (\"__typename\" in data && !(\"__typename\" in memo)) {\n    memo.__typename = data.__typename;\n  }\n  // This check prevents cases where masked fields may accidentally be\n  // returned as part of this object when the fragment also selects\n  // additional fields from the same child selection.\n  if (Object.keys(memo).length !== Object.keys(data).length) {\n    knownChanged.add(memo);\n  }\n  return knownChanged.has(memo) ? memo : data;\n}\nfunction getAccessorWarningDescriptor(fieldName, value, path, operationName, operationType) {\n  var getValue = function () {\n    if (disableWarningsSlot.getValue()) {\n      return value;\n    }\n    globalThis.__DEV__ !== false && invariant.warn(48, operationName ? \"\".concat(operationType, \" '\").concat(operationName, \"'\") : \"anonymous \".concat(operationType), \"\".concat(path, \".\").concat(fieldName).replace(/^\\./, \"\"));\n    getValue = function () {\n      return value;\n    };\n    return value;\n  };\n  return {\n    get: function () {\n      return getValue();\n    },\n    set: function (newValue) {\n      getValue = function () {\n        return newValue;\n      };\n    },\n    enumerable: true,\n    configurable: true\n  };\n}","map":{"version":3,"sources":["../../src/masking/maskDefinition.ts"],"names":[],"mappings":"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","sourcesContent":["import { Kind } from \"graphql\";\nimport type { FragmentDefinitionNode, SelectionSetNode } from \"graphql\";\nimport {\n  getFragmentMaskMode,\n  maybeDeepFreeze,\n  resultKeyNameFromField,\n} from \"../utilities/index.js\";\nimport type { FragmentMap } from \"../utilities/index.js\";\nimport type { ApolloCache } from \"../cache/index.js\";\nimport { disableWarningsSlot } from \"./utils.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\n\ninterface MaskingContext {\n  operationType: \"query\" | \"mutation\" | \"subscription\" | \"fragment\";\n  operationName: string | undefined;\n  fragmentMap: FragmentMap;\n  cache: ApolloCache<unknown>;\n  mutableTargets: WeakMap<any, any>;\n  knownChanged: WeakSet<any>;\n}\n\nexport function maskDefinition(\n  data: Record<string, any>,\n  selectionSet: SelectionSetNode,\n  context: MaskingContext\n) {\n  return disableWarningsSlot.withValue(true, () => {\n    const masked = maskSelectionSet(data, selectionSet, context, false);\n\n    if (Object.isFrozen(data)) {\n      maybeDeepFreeze(masked);\n    }\n    return masked;\n  });\n}\n\nfunction getMutableTarget(\n  data: Record<string, any>,\n  mutableTargets: WeakMap<any, any>\n): typeof data {\n  if (mutableTargets.has(data)) {\n    return mutableTargets.get(data);\n  }\n\n  const mutableTarget = Array.isArray(data) ? [] : Object.create(null);\n  mutableTargets.set(data, mutableTarget);\n  return mutableTarget;\n}\n\nfunction maskSelectionSet(\n  data: any,\n  selectionSet: SelectionSetNode,\n  context: MaskingContext,\n  migration: boolean,\n  path?: string | undefined\n): typeof data {\n  const { knownChanged } = context;\n  const memo = getMutableTarget(data, context.mutableTargets);\n\n  if (Array.isArray(data)) {\n    for (const [index, item] of Array.from(data.entries())) {\n      if (item === null) {\n        memo[index] = null;\n        continue;\n      }\n\n      const masked = maskSelectionSet(\n        item,\n        selectionSet,\n        context,\n        migration,\n        __DEV__ ? `${path || \"\"}[${index}]` : void 0\n      );\n      if (knownChanged.has(masked)) {\n        knownChanged.add(memo);\n      }\n\n      memo[index] = masked;\n    }\n\n    return knownChanged.has(memo) ? memo : data;\n  }\n\n  for (const selection of selectionSet.selections) {\n    let value: any;\n\n    // we later want to add acessor warnings to the final result\n    // so we need a new object to add the accessor warning to\n    if (migration) {\n      knownChanged.add(memo);\n    }\n\n    if (selection.kind === Kind.FIELD) {\n      const keyName = resultKeyNameFromField(selection);\n      const childSelectionSet = selection.selectionSet;\n\n      value = memo[keyName] || data[keyName];\n\n      if (value === void 0) {\n        continue;\n      }\n\n      if (childSelectionSet && value !== null) {\n        const masked = maskSelectionSet(\n          data[keyName],\n          childSelectionSet,\n          context,\n          migration,\n          __DEV__ ? `${path || \"\"}.${keyName}` : void 0\n        );\n\n        if (knownChanged.has(masked)) {\n          value = masked;\n        }\n      }\n\n      if (!__DEV__) {\n        memo[keyName] = value;\n      }\n      if (__DEV__) {\n        if (\n          migration &&\n          keyName !== \"__typename\" &&\n          // either the field is not present in the memo object\n          // or it has a `get` descriptor, not a `value` descriptor\n          // => it is a warning accessor and we can overwrite it\n          // with another accessor\n          !Object.getOwnPropertyDescriptor(memo, keyName)?.value\n        ) {\n          Object.defineProperty(\n            memo,\n            keyName,\n            getAccessorWarningDescriptor(\n              keyName,\n              value,\n              path || \"\",\n              context.operationName,\n              context.operationType\n            )\n          );\n        } else {\n          delete memo[keyName];\n          memo[keyName] = value;\n        }\n      }\n    }\n\n    if (\n      selection.kind === Kind.INLINE_FRAGMENT &&\n      (!selection.typeCondition ||\n        context.cache.fragmentMatches!(selection, data.__typename))\n    ) {\n      value = maskSelectionSet(\n        data,\n        selection.selectionSet,\n        context,\n        migration,\n        path\n      );\n    }\n\n    if (selection.kind === Kind.FRAGMENT_SPREAD) {\n      const fragmentName = selection.name.value;\n      const fragment: FragmentDefinitionNode | null =\n        context.fragmentMap[fragmentName] ||\n        (context.fragmentMap[fragmentName] =\n          context.cache.lookupFragment(fragmentName)!);\n      invariant(\n        fragment,\n        \"Could not find fragment with name '%s'.\",\n        fragmentName\n      );\n\n      const mode = getFragmentMaskMode(selection);\n\n      if (mode !== \"mask\") {\n        value = maskSelectionSet(\n          data,\n          fragment.selectionSet,\n          context,\n          mode === \"migrate\",\n          path\n        );\n      }\n    }\n\n    if (knownChanged.has(value)) {\n      knownChanged.add(memo);\n    }\n  }\n\n  if (\"__typename\" in data && !(\"__typename\" in memo)) {\n    memo.__typename = data.__typename;\n  }\n\n  // This check prevents cases where masked fields may accidentally be\n  // returned as part of this object when the fragment also selects\n  // additional fields from the same child selection.\n  if (Object.keys(memo).length !== Object.keys(data).length) {\n    knownChanged.add(memo);\n  }\n\n  return knownChanged.has(memo) ? memo : data;\n}\n\nfunction getAccessorWarningDescriptor(\n  fieldName: string,\n  value: any,\n  path: string,\n  operationName: string | undefined,\n  operationType: string\n): PropertyDescriptor {\n  let getValue = () => {\n    if (disableWarningsSlot.getValue()) {\n      return value;\n    }\n\n    invariant.warn(\n      \"Accessing unmasked field on %s at path '%s'. This field will not be available when masking is enabled. Please read the field from the fragment instead.\",\n      operationName ?\n        `${operationType} '${operationName}'`\n      : `anonymous ${operationType}`,\n      `${path}.${fieldName}`.replace(/^\\./, \"\")\n    );\n\n    getValue = () => value;\n\n    return value;\n  };\n\n  return {\n    get() {\n      return getValue();\n    },\n    set(newValue) {\n      getValue = () => newValue;\n    },\n    enumerable: true,\n    configurable: true,\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}