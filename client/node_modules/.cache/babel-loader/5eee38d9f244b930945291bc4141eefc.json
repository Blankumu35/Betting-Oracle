{"ast":null,"code":"import { Kind } from \"graphql\";\nimport { MapImpl, SetImpl, warnOnImproperCacheImplementation } from \"./utils.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport equal from \"@wry/equality\";\nimport { maskDefinition } from \"./maskDefinition.js\";\nimport { createFragmentMap, getFragmentDefinitions } from \"../utilities/index.js\";\n/** @internal */\nexport function maskFragment(data, document, cache, fragmentName) {\n  if (!cache.fragmentMatches) {\n    if (globalThis.__DEV__ !== false) {\n      warnOnImproperCacheImplementation();\n    }\n    return data;\n  }\n  var fragments = document.definitions.filter(function (node) {\n    return node.kind === Kind.FRAGMENT_DEFINITION;\n  });\n  if (typeof fragmentName === \"undefined\") {\n    invariant(fragments.length === 1, 49, fragments.length);\n    fragmentName = fragments[0].name.value;\n  }\n  var fragment = fragments.find(function (fragment) {\n    return fragment.name.value === fragmentName;\n  });\n  invariant(!!fragment, 50, fragmentName);\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n  if (equal(data, {})) {\n    // Return early and skip the masking algorithm if we don't have any data\n    // yet. This can happen when cache.diff returns an empty object which is\n    // used from watchFragment.\n    return data;\n  }\n  return maskDefinition(data, fragment.selectionSet, {\n    operationType: \"fragment\",\n    operationName: fragment.name.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache: cache,\n    mutableTargets: new MapImpl(),\n    knownChanged: new SetImpl()\n  });\n}","map":{"version":3,"sources":["../../src/masking/maskFragment.ts"],"names":[],"mappings":"AAAA,SAAS,IAAI,QAAQ,SAAS;AAO9B,SACE,OAAO,EACP,OAAO,EACP,iCAAiC,QAC5B,YAAY;AACnB,SAAS,SAAS,QAAQ,+BAA+B;AACzD,OAAO,KAAK,MAAM,eAAe;AACjC,SAAS,cAAc,QAAQ,qBAAqB;AACpD,SACE,iBAAiB,EACjB,sBAAsB,QACjB,uBAAuB;AAE9B;AACA,OAAM,SAAU,YAAY,CAC1B,IAAW,EACX,QAAiD,EACjD,KAA2B,EAC3B,YAAqB,EAAA;EAErB,IAAI,CAAC,KAAK,CAAC,eAAe,EAAE;IAC1B,IAAI,UAAU,CAAA,OAAA,KAAA,KAAA,EAAA;MACZ,iCAAiC,CAAA,CAAE;IACrC;IAEA,OAAO,IAAI;EACb;EAEA,IAAM,SAAS,GAAG,QAAQ,CAAC,WAAW,CAAC,MAAM,CAC3C,UAAC,IAAI,EAAA;IACH,OAAA,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,mBAAmB;EAAtC,CAAsC,CACzC;EAED,IAAI,OAAO,YAAY,KAAK,WAAW,EAAE;IACvC,SAAS,CACP,SAAS,CAAC,MAAM,KAAK,CAAC,EACtB,EAAA,EAAA,SAAA,CAAA,MAAA,CAAA;IAGF,YAAY,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK;EACxC;EAEA,IAAM,QAAQ,GAAG,SAAS,CAAC,IAAI,CAC7B,UAAC,QAAQ,EAAA;IAAK,OAAA,QAAQ,CAAC,IAAI,CAAC,KAAK,KAAK,YAAY;EAApC,CAAoC,CACnD;EAED,SAAS,CACP,CAAC,CAAC,QAAQ,EACV,EAAA,EAAA,YAAA,CAAA;EAIF,IAAI,IAAI,IAAI,IAAI,EAAE;IAChB;IACA,OAAO,IAAI;EACb;EAEA,IAAI,KAAK,CAAC,IAAI,EAAE,CAAA,CAAE,CAAC,EAAE;IACnB;IACA;IACA;IACA,OAAO,IAAI;EACb;EAEA,OAAO,cAAc,CAAC,IAAI,EAAE,QAAQ,CAAC,YAAY,EAAE;IACjD,aAAa,EAAE,UAAU;IACzB,aAAa,EAAE,QAAQ,CAAC,IAAI,CAAC,KAAK;IAClC,WAAW,EAAE,iBAAiB,CAAC,sBAAsB,CAAC,QAAQ,CAAC,CAAC;IAChE,KAAK,EAAA,KAAA;IACL,cAAc,EAAE,IAAI,OAAO,CAAA,CAAE;IAC7B,YAAY,EAAE,IAAI,OAAO,CAAA;GAC1B,CAAC;AACJ","sourcesContent":["import { Kind } from \"graphql\";\nimport type { FragmentDefinitionNode } from \"graphql\";\nimport type {\n  ApolloCache,\n  DocumentNode,\n  TypedDocumentNode,\n} from \"../core/index.js\";\nimport {\n  MapImpl,\n  SetImpl,\n  warnOnImproperCacheImplementation,\n} from \"./utils.js\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport equal from \"@wry/equality\";\nimport { maskDefinition } from \"./maskDefinition.js\";\nimport {\n  createFragmentMap,\n  getFragmentDefinitions,\n} from \"../utilities/index.js\";\n\n/** @internal */\nexport function maskFragment<TData = unknown>(\n  data: TData,\n  document: TypedDocumentNode<TData> | DocumentNode,\n  cache: ApolloCache<unknown>,\n  fragmentName?: string\n): TData {\n  if (!cache.fragmentMatches) {\n    if (__DEV__) {\n      warnOnImproperCacheImplementation();\n    }\n\n    return data;\n  }\n\n  const fragments = document.definitions.filter(\n    (node): node is FragmentDefinitionNode =>\n      node.kind === Kind.FRAGMENT_DEFINITION\n  );\n\n  if (typeof fragmentName === \"undefined\") {\n    invariant(\n      fragments.length === 1,\n      `Found %s fragments. \\`fragmentName\\` must be provided when there is not exactly 1 fragment.`,\n      fragments.length\n    );\n    fragmentName = fragments[0].name.value;\n  }\n\n  const fragment = fragments.find(\n    (fragment) => fragment.name.value === fragmentName\n  );\n\n  invariant(\n    !!fragment,\n    `Could not find fragment with name \"%s\".`,\n    fragmentName\n  );\n\n  if (data == null) {\n    // Maintain the original `null` or `undefined` value\n    return data;\n  }\n\n  if (equal(data, {})) {\n    // Return early and skip the masking algorithm if we don't have any data\n    // yet. This can happen when cache.diff returns an empty object which is\n    // used from watchFragment.\n    return data;\n  }\n\n  return maskDefinition(data, fragment.selectionSet, {\n    operationType: \"fragment\",\n    operationName: fragment.name.value,\n    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n    cache,\n    mutableTargets: new MapImpl(),\n    knownChanged: new SetImpl(),\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}