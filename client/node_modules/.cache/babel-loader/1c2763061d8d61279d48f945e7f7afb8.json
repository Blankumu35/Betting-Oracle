{"ast":null,"code":"import * as React from \"rehackt\";\nimport { assertWrappedQueryRef, getWrappedPromise, unwrapQueryRef, updateWrappedQueryRef, wrapQueryRef } from \"../internal/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { wrapHook } from \"./internal/index.js\";\n/**\n * A React hook that returns a `refetch` and `fetchMore` function for a given\n * `queryRef`.\n *\n * This is useful to get access to handlers for a `queryRef` that was created by\n * `createQueryPreloader` or when the handlers for a `queryRef` produced in\n * a different component are inaccessible.\n *\n * @example\n * ```tsx\n * const MyComponent({ queryRef }) {\n *   const { refetch, fetchMore } = useQueryRefHandlers(queryRef);\n *\n *   // ...\n * }\n * ```\n * @since 3.9.0\n * @param queryRef - A `QueryRef` returned from `useBackgroundQuery`, `useLoadableQuery`, or `createQueryPreloader`.\n */\nexport function useQueryRefHandlers(queryRef) {\n  var unwrapped = unwrapQueryRef(queryRef);\n  var clientOrObsQuery = useApolloClient(unwrapped ?\n  // passing an `ObservableQuery` is not supported by the types, but it will\n  // return any truthy value that is passed in as an override so we cast the result\n  unwrapped[\"observable\"] : undefined);\n  return wrapHook(\"useQueryRefHandlers\",\n  // eslint-disable-next-line react-compiler/react-compiler\n  useQueryRefHandlers_, clientOrObsQuery)(queryRef);\n}\nfunction useQueryRefHandlers_(queryRef) {\n  assertWrappedQueryRef(queryRef);\n  var _a = React.useState(queryRef),\n    previousQueryRef = _a[0],\n    setPreviousQueryRef = _a[1];\n  var _b = React.useState(queryRef),\n    wrappedQueryRef = _b[0],\n    setWrappedQueryRef = _b[1];\n  var internalQueryRef = unwrapQueryRef(queryRef);\n  // To ensure we can support React transitions, this hook needs to manage the\n  // queryRef state and apply React's state value immediately to the existing\n  // queryRef since this hook doesn't return the queryRef directly\n  if (previousQueryRef !== queryRef) {\n    setPreviousQueryRef(queryRef);\n    setWrappedQueryRef(queryRef);\n  } else {\n    updateWrappedQueryRef(queryRef, getWrappedPromise(wrappedQueryRef));\n  }\n  var refetch = React.useCallback(function (variables) {\n    var promise = internalQueryRef.refetch(variables);\n    setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n    return promise;\n  }, [internalQueryRef]);\n  var fetchMore = React.useCallback(function (options) {\n    var promise = internalQueryRef.fetchMore(options);\n    setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n    return promise;\n  }, [internalQueryRef]);\n  return {\n    refetch: refetch,\n    fetchMore: fetchMore,\n    // TODO: The internalQueryRef doesn't have TVariables' type information so we have to cast it here\n    subscribeToMore: internalQueryRef.observable.subscribeToMore\n  };\n}","map":{"version":3,"sources":["../../../src/react/hooks/useQueryRefHandlers.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAK,MAAM,SAAS;AAChC,SACE,qBAAqB,EACrB,iBAAiB,EACjB,cAAc,EACd,qBAAqB,EACrB,YAAY,QACP,sBAAsB;AAM7B,SAAS,eAAe,QAAQ,sBAAsB;AACtD,SAAS,QAAQ,QAAQ,qBAAqB;AAgB9C;;;;;;;;;;;;;;;;;;AAkBG;AACH,OAAM,SAAU,mBAAmB,CAIjC,QAAqC,EAAA;EAErC,IAAM,SAAS,GAAG,cAAc,CAAC,QAAQ,CAAC;EAC1C,IAAM,gBAAgB,GAAG,eAAe,CACtC,SAAS;EACP;EACA;EACC,SAAS,CAAC,YAAY,CAAS,GAChC,SAAS,CACkC;EAE/C,OAAO,QAAQ,CACb,qBAAqB;EACrB;EACA,oBAAoB,EACpB,gBAAgB,CACjB,CAAC,QAAQ,CAAC;AACb;AAEA,SAAS,oBAAoB,CAI3B,QAAqC,EAAA;EAErC,qBAAqB,CAAC,QAAQ,CAAC;EACzB,IAAA,EAAA,GAA0C,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC;IAAjE,gBAAgB,GAAA,EAAA,CAAA,CAAA,CAAA;IAAE,mBAAmB,GAAA,EAAA,CAAA,CAAA,CAA4B;EAClE,IAAA,EAAA,GAAwC,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC;IAA/D,eAAe,GAAA,EAAA,CAAA,CAAA,CAAA;IAAE,kBAAkB,GAAA,EAAA,CAAA,CAAA,CAA4B;EACtE,IAAM,gBAAgB,GAAG,cAAc,CAAC,QAAQ,CAAC;EAEjD;EACA;EACA;EACA,IAAI,gBAAgB,KAAK,QAAQ,EAAE;IACjC,mBAAmB,CAAC,QAAQ,CAAC;IAC7B,kBAAkB,CAAC,QAAQ,CAAC;EAC9B,CAAC,MAAM;IACL,qBAAqB,CAAC,QAAQ,EAAE,iBAAiB,CAAC,eAAe,CAAC,CAAC;EACrE;EAEA,IAAM,OAAO,GAAuC,KAAK,CAAC,WAAW,CACnE,UAAC,SAAS,EAAA;IACR,IAAM,OAAO,GAAG,gBAAgB,CAAC,OAAO,CAAC,SAAS,CAAC;IAEnD,kBAAkB,CAAC,YAAY,CAAC,gBAAgB,CAAC,CAAC;IAElD,OAAO,OAAO;EAChB,CAAC,EACD,CAAC,gBAAgB,CAAC,CACnB;EAED,IAAM,SAAS,GAAyC,KAAK,CAAC,WAAW,CACvE,UAAC,OAAO,EAAA;IACN,IAAM,OAAO,GAAG,gBAAgB,CAAC,SAAS,CACxC,OAA0C,CAC3C;IAED,kBAAkB,CAAC,YAAY,CAAC,gBAAgB,CAAC,CAAC;IAElD,OAAO,OAAO;EAChB,CAAC,EACD,CAAC,gBAAgB,CAAC,CACnB;EAED,OAAO;IACL,OAAO,EAAA,OAAA;IACP,SAAS,EAAA,SAAA;IACT;IACA,eAAe,EAAE,gBAAgB,CAAC,UAAU,CACzC;GACJ;AACH","sourcesContent":["import * as React from \"rehackt\";\nimport {\n  assertWrappedQueryRef,\n  getWrappedPromise,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n  wrapQueryRef,\n} from \"../internal/index.js\";\nimport type { QueryRef } from \"../internal/index.js\";\nimport type { OperationVariables } from \"../../core/types.js\";\nimport type { SubscribeToMoreFunction } from \"../../core/watchQueryOptions.js\";\nimport type { RefetchFunction, FetchMoreFunction } from \"./useSuspenseQuery.js\";\nimport type { FetchMoreQueryOptions } from \"../../core/watchQueryOptions.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { wrapHook } from \"./internal/index.js\";\nimport type { ApolloClient } from \"../../core/ApolloClient.js\";\nimport type { ObservableQuery } from \"../../core/ObservableQuery.js\";\n\nexport interface UseQueryRefHandlersResult<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> {\n  /** {@inheritDoc @apollo/client!ObservableQuery#refetch:member(1)} */\n  refetch: RefetchFunction<TData, TVariables>;\n  /** {@inheritDoc @apollo/client!ObservableQuery#fetchMore:member(1)} */\n  fetchMore: FetchMoreFunction<TData, TVariables>;\n  /** {@inheritDoc @apollo/client!ObservableQuery#subscribeToMore:member(1)} */\n  subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n}\n\n/**\n * A React hook that returns a `refetch` and `fetchMore` function for a given\n * `queryRef`.\n *\n * This is useful to get access to handlers for a `queryRef` that was created by\n * `createQueryPreloader` or when the handlers for a `queryRef` produced in\n * a different component are inaccessible.\n *\n * @example\n * ```tsx\n * const MyComponent({ queryRef }) {\n *   const { refetch, fetchMore } = useQueryRefHandlers(queryRef);\n *\n *   // ...\n * }\n * ```\n * @since 3.9.0\n * @param queryRef - A `QueryRef` returned from `useBackgroundQuery`, `useLoadableQuery`, or `createQueryPreloader`.\n */\nexport function useQueryRefHandlers<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  queryRef: QueryRef<TData, TVariables>\n): UseQueryRefHandlersResult<TData, TVariables> {\n  const unwrapped = unwrapQueryRef(queryRef);\n  const clientOrObsQuery = useApolloClient(\n    unwrapped ?\n      // passing an `ObservableQuery` is not supported by the types, but it will\n      // return any truthy value that is passed in as an override so we cast the result\n      (unwrapped[\"observable\"] as any)\n    : undefined\n  ) as ApolloClient<any> | ObservableQuery<TData>;\n\n  return wrapHook(\n    \"useQueryRefHandlers\",\n    // eslint-disable-next-line react-compiler/react-compiler\n    useQueryRefHandlers_,\n    clientOrObsQuery\n  )(queryRef);\n}\n\nfunction useQueryRefHandlers_<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  queryRef: QueryRef<TData, TVariables>\n): UseQueryRefHandlersResult<TData, TVariables> {\n  assertWrappedQueryRef(queryRef);\n  const [previousQueryRef, setPreviousQueryRef] = React.useState(queryRef);\n  const [wrappedQueryRef, setWrappedQueryRef] = React.useState(queryRef);\n  const internalQueryRef = unwrapQueryRef(queryRef);\n\n  // To ensure we can support React transitions, this hook needs to manage the\n  // queryRef state and apply React's state value immediately to the existing\n  // queryRef since this hook doesn't return the queryRef directly\n  if (previousQueryRef !== queryRef) {\n    setPreviousQueryRef(queryRef);\n    setWrappedQueryRef(queryRef);\n  } else {\n    updateWrappedQueryRef(queryRef, getWrappedPromise(wrappedQueryRef));\n  }\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = internalQueryRef.refetch(variables);\n\n      setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n\n      return promise;\n    },\n    [internalQueryRef]\n  );\n\n  const fetchMore: FetchMoreFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      const promise = internalQueryRef.fetchMore(\n        options as FetchMoreQueryOptions<any, any>\n      );\n\n      setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n\n      return promise;\n    },\n    [internalQueryRef]\n  );\n\n  return {\n    refetch,\n    fetchMore,\n    // TODO: The internalQueryRef doesn't have TVariables' type information so we have to cast it here\n    subscribeToMore: internalQueryRef.observable\n      .subscribeToMore as SubscribeToMoreFunction<TData, TVariables>,\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}